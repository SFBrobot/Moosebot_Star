#pragma config(Sensor, dgtl1,  claw1,          sensorDigitalOut)
#pragma config(Sensor, dgtl2,  claw2,          sensorDigitalOut)
#pragma config(Motor,  port1,           lfWheel,       tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           lbWheel,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           aMotor,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           bMotor,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           cMotor,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           dMotor,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           eMotor,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           fMotor,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           rbWheel,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          rfWheel,       tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "Vex_Competition_Includes.c"

#define RX 0
#define RY 1
#define LY 2
#define LX 3

/*#define clawMtr(pwr) motor[lClaw] = \
//	motor[rClaw] = \
	pwr
*/
	
#define arm(pwr) motor[aMotor] = \
	motor[bMotor] = \
	motor[cMotor] = \
	motor[dMotor] = \
	motor[eMotor] = \
	motor[fMotor] = \
	pwr

#define lDrive(pwr) motor[lfWheel] = \
	motor[lbWheel] = \
	pwr
	
#define rDrive(pwr) motor[rfWheel] = \
	motor[rbWheel] = \
	pwr

bool pnClaw(bool in) {
	if(SensorValue[claw1] ^ in) {
		if(in)
			SensorValue[claw1] =
				SensorValue[claw2] =
				true;
		else
			SensorValue[claw1] =
				SensorValue[claw2] =
				false;
	}
	return in;
}
	
void driveForTime(int pwrA, int pwrB, int s) { // Function for the standard drive of the robot.
	motor[lfWheel] = motor[lbWheel] = pwrA;
	motor[rfWheel] = motor[rbWheel] = pwrB;
	wait1Msec(s);
}

void armForTime(int pwr, int s) { // Function for the arm of the robot.
	arm(pwr);
	wait1Msec(s);
}
//Bottom motors on each side are inverted. Top one is not.

//void clawForTime(int pwr, int s) { // Function for the claw of the robot.
//	clawMtr(pwr);
//	wait1Msec(s);
//}

void pre_auton() { } // Function to set values before the match starts

task autonomous() { // Function that runs the autonomous program.

	pnClaw(1);
	armForTime(127, 200); // Raises the arm up.
	armForTime(0, 350); // Stops the arm.
	armForTime(-127, 100); // Lowers the arm.
	armForTime(0, 350); // Stops the arm.

}

task usercontrol() // Function for user control.
{
	
	int stick[4];

	while(true) { // Loops the code until the map is over.
		
		for(int i = 0; i < 4; i++) { //Iterate over all 4 joystick axes
			if(abs(vexRT[i]) >= 7) //If stick value is outside deadband 
				stick[i] = vexRT[i];
			else
				stick[i] = 0;
		}
		
		lDrive(stick[LY] + stick[RX]);
		rDrive(stick[LY] - stick[RX]);		

	if(vexRT[Btn6U] ^ vexRT[Btn6D])
		pnClaw(vexRT[Btn6U]);
		
	if(vexRT[Btn5U]) // Checks if a button is pressed, and if so, raises the arm.
		arm(127);
	else if(vexRT[Btn5D]) // Checks if a button is pressed, and if so, lowers the arm.
		arm(-127);
	else // Checks if a button is pressed, and if so, stops the arm.
		arm(0);


	}
}

void allMotorsOff() { }
void allTasksStop() { }
