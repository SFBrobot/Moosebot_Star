#pragma config(Motor,  port1,           lfWheel,       tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           lbWheel,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           aMotor,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           bMotor,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           lClaw,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           rClaw,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           cMotor,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           dMotor,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           rbWheel,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          rfWheel,       tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "Vex_Competition_Includes.c"

void standard(int pwrA, int pwrB, int s) { // Function for the standard drive of the robot.
	motor[lfWheel] = motor[lbWheel] = pwrA;
	motor[rfWheel] = motor[rbWheel] = pwrB;
	wait1Msec(s);
}
void arm(int pwr, int s) { // Function for the arm of
	motor[aMotor] = motor[bMotor] = motor[cMotor] = motor[dMotor] = pwr;
	wait1Msec(s);
}
void clawMovement(int pwr, int s) {
	motor[lClaw] = pwr;
	motor[rClaw] = pwr;
	wait1Msec(s);
}

void pre_auton() { }

task autonomous() {

	clawMovement(-127, 300); // Opens the claw.
	clawMovement(0, 200);
	arm(127, 200);
	arm(0, 350);
	arm(-127, 100);
	arm(0, 350);
	standard(127, 127, 1400);
	standard(0, 0, 350);
	clawMovement(127, 850);
	clawMovement(0, 300);
	standard(-127, -70, 500);
	standard(0, 0, 200);
	standard(-127, 127, 345);
	standard(0, 0, 200);
	standard(-127, -127, 2000);
	standard(0, 0, 200);
	arm(127, 1500);
	arm(0, 200);
	clawMovement(127, 750);
	clawMovement(0, 250);
	clawMovement(-127, 750);
	clawMovement(0, 250);
	arm(-127, 1500);
	arm(0, 250);

}

task usercontrol()
{
	while(true) {
		motor[lfWheel] = motor[lbWheel] = vexRT[Ch3] + vexRT[Ch1];
		motor[rfWheel] = motor[rbWheel] = vexRT[Ch3] - vexRT[Ch1];
	if(vexRT[Btn6U] == 1) {
		motor[lClaw] = 127;
		motor[rClaw] = 127;
}
	else if(vexRT[Btn6D] == 1) {
		motor[lClaw] = -127;
		motor[rClaw] = -127;
}
	else {
	motor[lClaw] = 0;
	motor[rClaw] = 0;
}
		if(vexRT[Btn5U] == 1) {
			motor[aMotor] = 127;
			motor[bMotor] = 127;
			motor[cMotor] = 127;
			motor[dMotor] = 127;
	}
		else if(vexRT[Btn5D] == 1) {
			motor[aMotor] = -127;
			motor[bMotor] = -127;
			motor[cMotor] = -127;
			motor[dMotor] = -127;
	}
		else {
			motor[aMotor] = 0;
			motor[bMotor] = 0;
			motor[cMotor] = 0;
			motor[dMotor] = 0;
	}


	}
}

void allMotorsOff() { }
void allTasksStop() { }
